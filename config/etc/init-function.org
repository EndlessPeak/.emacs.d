* init-function.el
:PROPERTIES:
:HEADER-ARGS: :tangle (concat temporary-file-directory "init-function.el") :lexical t
:END:

** Headers
#+begin_src emacs-lisp
  ;;; init-function.el ---   -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;;; Code :
#+end_src

** Proxy
#+begin_src emacs-lisp
  (defvar leesin/proxy-enabled nil)
  (defun leesin/toggle-proxy ()
    (interactive)
    (if leesin/proxy-enabled
        (progn
          (setq url-proxy-services nil)
          (setq leesin/proxy-enabled nil)
          (message "代理已关闭."))
        (progn
          (when sys/win32p
              (setq url-proxy-services
                  '(("http" . "127.0.0.1:10809")
                      ("https" . "127.0.0.1:10809"))))
          (when sys/linux
              (setq url-proxy-services
                  '(("http" . "127.0.0.1:20171")
                      ("https" . "127.0.0.1:20171"))))
          (setq leesin/proxy-enabled t)
          (message "代理已开启."))))
#+end_src

由于下面的代码实测无法正确执行，因而不参与编译。
#+begin_src emacs-lisp :tangle no
  ;; Function Defination
  (defun leesin/toggle-proxy ()
    (interactive)
    (if (null url-proxy-services)
        (when sys/win32p
          (progn
              (setq url-proxy-services
                  '(("http" . "127.0.0.1:10809")
                      ("https" . "127.0.0.1:10809")))
              (message "代理已开启.")))
        (when sys/linux
          (progn
              (setq url-proxy-services
                  '(("http" . "127.0.0.1:20171")
                      ("https" . "127.0.0.1:20171")))
              (message "代理已开启.")))
      (setq url-proxy-services nil)
      (message "代理已关闭.")))
#+end_src

** Transparency
透明背景目前 =emacs= 已支持。
#+begin_src emacs-lisp
  (defun leesin/toggle-transparency()
    (setq default-frame-alist '((alpha-background . 95)))
    )
  (leesin/toggle-transparency)
#+end_src
原透明函数已弃用，不会参与编译。
#+begin_src emacs-lisp :tangle no
  ;;;###autoload
  (defun leesin/toggle-transparency()
    (interactive)
    (let ((alpha (frame-parameter nil 'alpha)))
      (set-frame-parameter
       nil 'alpha
       (if (eql (cond ((numberp alpha) alpha)
                      ((numberp (cdr alpha)) (cdr alpha))
                      ((numberp (cadr alpha)) (cadr alpha)))
                100)
                '(70 . 70) '(100 . 100)))))
#+end_src

** Animate text
用于录制视频时开头播放字符动画。
#+begin_src emacs-lisp
  (defun animate-text (text)
    ;; https://github.com/matrixj/405647498.github.com/blob/gh-pages/src/emacs/emacs-fun.org
    (interactive "stext: ")  ; s means read-string
    (switch-to-buffer (get-buffer-create "*butterfly*"))
    (erase-buffer)
    (animate-string text 10))
#+end_src

** Indent Region
用于设置在任何编程模式中 =tab= 键的缩进。
*** Indent Region
#+begin_src emacs-lisp
  (defun leesin/indent-region (numSpaces)
    "该函数会根据当前行或选区的起始和终止位置，将这些行的文本进行缩进处理。"
    (let ((regionStart nil)
          (regionEnd nil)
          (start nil)
          (end nil))
      (progn
        ; 默认是当前行的起始位置和终止位置
        (setq regionStart (line-beginning-position))
        (setq regionEnd (line-end-position))

        ; 如果有选区，则使用选区的起始位置和终止位置
        (when (use-region-p)
          (setq regionStart (region-beginning))
          (setq regionEnd (region-end)))

        (save-excursion
          ;; 通过`narrow-to-region'和`widen'修复缩进影响下一行
          ;; 限制缩进范围
          (narrow-to-region regionStart regionEnd)

          ; 恢复位置
          (goto-char regionStart)                ; 移动到选区的起始位置
          (setq start (line-beginning-position)) ; 保存行的起始位置
          (goto-char regionEnd)                  ; 移动到选区的终止位置
          (setq end (line-end-position))         ; 保存行的终止位置

          ; 对 start 和 end 之间的文本进行缩进
          (indent-rigidly start end numSpaces)
          (setq deactivate-mark nil) ; 恢复选区
          ;; 修复缩进范围
          (widen)
          )
        )
      )
    )
#+end_src

*** Untab Region
#+begin_src emacs-lisp
  (defun leesin/untab-region ()
    "命令函数，它的作用是将选定的文本块反向缩进。"
    ;; 如果存在选区，则调用 `leesin/indent-region' 函数，并计算缩进值传递给它。
    ;; 如果没有选区，则计算需要反向缩进多少，并使用 `delete-char'
    (interactive)
    ;; (leesin/indent-region -4)
    ;; `bolp' 仅适用于判断单个点，而不适用于选区
    (if (use-region-p)
        (let* ((start (region-beginning))
               ;;(end (region-end)) ;; end is unused
               ;; 获取选区的开始行
               (line-start (line-number-at-pos start))
               ;; 根据`line-beginning-position'获取该行的起始列号
               (movement (% (- start (line-beginning-position line-start)) tab-width))
               (spaces (- (if (= 0 movement) tab-width
                            (- tab-width movement)))))
          ;;(goto-char start)
          (leesin/indent-region spaces))
      )
    (unless (bolp)
      (save-excursion
        (when (> (current-column) (current-indentation))
          (back-to-indentation))
        (let* ((movement (% (current-column) tab-width))
               (spaces (- (if (= 0 movement) tab-width
                           (- tab-width movement)))))
            (delete-char spaces))))
    )
#+end_src
*** Tab Region
#+begin_src emacs-lisp
  (defun leesin/tab-region ()
    "命令函数，它用于将选定的文本块缩进。"
    (interactive)
    ;; 如果存在选区，则调用 `leesin/indent-region' 函数，并计算缩进值传递给它。
    (let* ((movement (% (current-column) tab-width))
           (spaces (if (= 0 movement) tab-width (- tab-width movement))))
    ;; 如果没有选区，则计算需要缩进的空格数，并使用 `insert'  
    (if (use-region-p)
        (leesin/indent-region spaces)
      (insert (make-string spaces ? ))))
    )
#+end_src
*** Redefine Tab Key
#+begin_src emacs-lisp
  (defun leesin/hack-tab-key ()
    "命令函数，它重新定义了 <tab> 和 <backtab> 键的行为。"
    ;; 通过调用 local-set-key 函数，它将 <tab> 键绑定到 leesin/tab-region 函数，将 <backtab> 键绑定到 leesin/untab-region 函数。
    (interactive)
    (local-set-key (kbd "<tab>") 'leesin/tab-region)
    (local-set-key (kbd "<backtab>") 'leesin/untab-region))

  (add-hook 'prog-mode-hook 'leesin/hack-tab-key)
#+end_src
** Ends
#+begin_src emacs-lisp
  (provide 'init-function)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; init-function.el ends here
#+end_src
